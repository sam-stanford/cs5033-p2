\subsection{Current Considerations}
\label{sect: evaluation: current considerations}



\subsubsection*{Architect Biases}
An important consideration when developing a software architecture style is ensuring that the architects are able to view the system context in an objective manner, in order to evaluate the expectations and requirements appropriately. However, bias can be introduced when the architects have had experience working with different architectural styles and patterns in the past, as this familiarity can sometimes cause architects to be further inclined to work with such architectural frameworks again. This makes it difficult for the architectural team to objectively evaluate the appropriate style for a particular scenario.

Due to this reason, the team had a planning phase (see S\ref{sect: process: phases}), where the Architecture Trade-off Analysis Method (ATAM) was employed, which is a risk-mitigation process that is used to assess trade-offs and sensitivity points. This allowed the team to outline the desired architectural characteristics of the system, which made it much simpler to evaluate the different architectural options against these criteria, thereby enabling us to make more objective decisions. This process also enabled the team to identify the risks that needed to be considered during the development of the software, such as ensuring that the system is able to handle malicious attacks and handle data appropriately. Furthermore, this process also enabled the team to identify the different stakeholders within the system and ensure that the system was able to handle all their respective requirements.

Thus, this method was extremely useful to ensure that the team was able to view the system requirements through an objective lens, and ensure that each architectural characteristic was preserved.



\subsubsection*{Data Loss in Event-Driven Styles}
The use of event-driven styles within the architecture includes the pub-sub messaging systems employed in the GP Notification Service (see \S\ref{sect: architecture: gp notification svc}) and the Ambulance Service (see \S\ref{sect: architecture: ambulance svc}), as well as the multilevel priority queue used in the Patient Information Service (see \S\ref{sect: architecture: patient information svc}). Each of these applications of event-driven architecture comes with the risk of data being lost, as the intermediate stores for the respective \say{events} are memory-based, meaning that data will be lost upon service failure if the correct precautions are not taken.

The proposed architecture takes step to mitigate data loss within the GP Notification Service by backing-up notifications which are buffered within the pub-sub messaging system to a resilient datastore (see \S\ref{sect: architecture: gp notification svc}); the Ambulance Service's pub-sub system also has similar functionality. Steps can also be taken with pub-sub systems involving acknowledgement messages (acks) to ensure that messages are only removed from the pub-sub system once they have been correctly handled by the message receiver \cite{googleCloudPubSub}; however, this concern is not facilitated by the architecture and instead relies on developer vigilance to be implemented correctly.

However, the multilevel priority queue within the Patient Information Service does not currently have any architectural support for providing fault-tolerance with respect to write requests which arrive in the queue. Improvements to the architecture could include the use of a simple append-only log-file to reduce the amount of data lost in a fault, and more complex fault-tolerance mechanics could be applied to mitigate almost all data loss; however, the overhead introduced by such a scheme could be counterintuitive as much patient data (e.g. blood pressure readings) could likely be regenerated fairly easily.




\subsubsection*{Authentication Performance Bottleneck}
The support for authentication provided by the architecture offers many benefits, as discussed in Section \ref{sect: architecture: authentication}. However, as all client devices must communicate with the Authentication Service in order to access the internal services' functionality (see \S\ref{sect: architecture: authentication}), there is a significant risk that the Authentication Service will become a bottleneck for the system.

Solutions to this problem could include replicating the Authentication Service, with replicas either set to handle a specific user type (e.g. GP staff) or being distributed geographically to reduce latency for user's connection with the Authentication Service. It should be noted that replicating the service could incur significant overhead to the system, meaning that replication should only be used if absolutely required \cite{dataIntensiveApps-NoReplicationIsBetter}.


\subsubsection*{BFF \& Gateway Patterns}
As discussed in Section \ref{sect: architecture: clients}, both the backend-for-frontend (BFF) pattern and gateway pattern are applied within the system's client architectures. Many systems will either employ one pattern or the other, but rarely both together, as the benefits they provide overlap significantly; in fact, the two patterns are sometimes considered synonymous \cite{bffsCouldBeConsideredGateways}. The use of both patterns introduces one extra level of indirection to an extra service node, increasing complexity and incurring a network overhead, both of which could be avoided by using only one of the two patterns.

However, as discussed in Section \ref{sect: architecture: clients}, while the gateway and BFF patterns provide some shared functionality, they also provide functionality unique to each pattern which would be more difficult to apply with the use of only a single pattern.

A potential improvement to this area of the architecture is removing the gateway nodes from the architecture and including their functionality within the BFF nodes through, with the use of the sidecar pattern being employed to provide the shared functionality reuse provided by the gateway pattern without incurring the extra overhead \cite{fundamentalsOfSWA-Microservices}.





\subsubsection*{Size}
Another important point of reflection refers to the size of the teams working on each individual component of the architecture and its subsequent implication.

This is because it can often be complex to split the development process appropriately, as each team needs to be fully briefed on the architectural description, and the methodology to implement the constraints and design specified. Thus, the architectural owner or the architectural owner team must be able to effectively communicate the parameters of the architectural framework to the developers, in order to ensure that the system is developed as intended.







\subsubsection*{Data Security}
One key consideration for the target system is that of data security, as patient health data can be considered to be very sensitive information \cite{EUHealthDataProtection}. In evaluating the proposed architecture, it can be seen that the architecture supports the implementation of data security in the following ways.

\begin{itemize}
  \item All sensitive data is stored in a single datastore within the Patient Information Service (see \S\ref{sect: architecture: patient information svc}). This means that the introduction and management of security policies and measures is greatly facilitated during the system's implementation and lifecycle.
  \item The integration of the OAuth 2 framework within the architecture facilitates the secure authentication of users using a modern protocol (see \S\ref{sect: architecture: authentication}).
\end{itemize}




\subsection{Lifecycle Considerations}
\label{sect: evaluation: lifecycle considerations}

An important consideration of this system refers to its maintainability. As this system is an example of critical software, it is essential to ensure that the system is maintainable and that any additions to the system functionality are conducted in accordance with the specified architecture.

As the architecture has been designed with specific architectural characteristics in mind, it is essential to ensure that any modifications are made in accordance to the designed system architecture. This is essential to prevent architectural drift and architectural erosion, i.e., the introduction of design decisions that are not included within the prescribed architectural style/pattern, or the introduction of design decisions that are in direct violation of the prespecified architecture.

As systems evolve, and as the initial development team is succeeded by subsequent maintenance teams, it becomes much harder to maintain the sanctity of an established architectural framework, and thus, it is much easier to run into issues of architectural drift and erosion.

Thus, in order to mitigate this issue, it is essential to maintain up-to-date documentation, that is appropriately updated, whenever changes are made or new functionality is added. As such, it should be essential to update the documentation whenever any changes to the system are made.

Furthermore, the application of component principles in the development of this system architecture is a simple way to address this issue, as developers can ensure that they are familiar with the architectural requirements of each component before they modify or update it.

As different aspects of functionality are contained within a modular structure, it is extremely easy to update these capabilities in an insular manner, and ensure that any changes work with the rest of the system, before release. This can be done through Continuous Integration/Continuous Development (CI/CD) pipelines.
Furthermore, the component architecture of this system enables functionality to be reused throughout the system, with the assurance that this functionality has been tested in a robust environment, which is an essential criterion for a critical system.
