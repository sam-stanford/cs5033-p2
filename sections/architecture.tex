\subsection{Modelling Language}
\label{sect: architecture: modelling language}

A relatively informal modelling language is used to describe the final architecture produced for this report, with the C4 Model being employed in combination with a notation similar to UML. This choice was made as all team members were relatively familiar with the concepts used in both practices, focussing the project's time to designing and evaluating the architecture, rather than learning modelling languages.



\subsubsection*{C4 Model}
The C4 Model primarily consists of four different architectural viewpoints, described in the form of diagrams, which represent an architecture as a hierarchical set of abstractions \cite{c4Model}. The viewpoints are designed to reflect how software architects and developers think about and build software, and are summarised as follows.

\begin{itemize}
  \item \textbf{System Context Diagram}: A viewpoint which describes a system's architecture as a whole, allowing viewers to see the \say{big picture}. The diagram has a focus on the users of the system, rather than specific details, such as which technologies are used. Section \ref{sect: architecture: overview} explores the system context diagram for the chosen architecture in this report.

  \item \textbf{Container Diagram}: A viewpoint which shows the details of a single subsystem within a system context diagram. The diagram is composed of containers, which represent an application or datastore (e.g. a web application, filesystem, database, etc.), and high-level references to other subsystems. Sections \ref{sect: architecture: appt svc}, \ref{sect: architecture: ambulance svc}, \ref{sect: architecture: gp notification svc}, and \ref{sect: architecture: patient information svc} display container diagrams for the subsystems which they describe.

  \item \textbf{Component Diagram}: A viewpoint which describes a single container within a container diagram, with respect to the major building blocks (i.e. components) that make up the container. Component diagrams contain some specific details, such as the technology used to implement or communicated between services, but still provide a relatively high-level overview of a container. Only a limited number of component diagrams are used to describe the proposed architecture for the sake of brevity; Sections \ref{sect: architecture: patient information svc} and \ref{sect: architecture: gp notification svc} display a component diagram for the parts of the architecture which they describe.

  \item \textbf{Code Diagram}: A viewpoint which describes a single component within a component diagram as it is implemented within code, including the classes and interface involved, and their relationships. Code diagrams are not explored in this report, as they reference relatively low-level implementation details, and could be automatically generated from code written during the system's development. No code diagrams are displayed in this report, as they are typically auto-generated from a codebase \cite{c4Model}.
\end{itemize}



The C4 Model also includes three supplementary diagrams: the system landscape diagram, the dynamic diagram, and the deployment diagram. However, none of these are reference within this report, as the four core diagrams are sufficient to capture the chosen architecture \cite{c4Model}.


\subsection{Notation}
A UML-like notation is used within the C4 Model diagrams, as group members were relatively familiar with the technology. The notation is a hybrid between UML \cite{umlSpec} and the suggested C4 Model notation \cite{c4Model} to keep the diagrams understandable and focussed. It is also worth noting that the diagrams are purely structural, they do not indicate how elements interact as this is described elsewhere only that the elements are communicating with each other.





\subsection{Overview}
\label{sect: architecture: overview}

The architecture derived for the scenario listed in Appendix \ref{appendix: scenario} is fundamentally a service-oriented architecture (SOA), as the key functionality of the system is provided by multiple independent, distributed services. The core services used and their roles within the architecture are as follows.

\begin{itemize}
  \item \textbf{Appointments Service}: Handles create, read, update, and delete (CRUD) operations relating to appointments, employing business rules in combination with authentication to authorise information appropriately. This service is described further in Section \ref{sect: architecture: appt svc}.

  \item \textbf{Patient Information Service}: Handles CRUD operations relating to patient information, authorising information similarly to the Appointments Service. This service is described further in Section \ref{sect: architecture: patient information svc}.

  \item \textbf{Ambulance Service}: Affords the logging of calls and the dispatching of ambulances. This service is described further in Section \ref{sect: architecture: ambulance svc}.

  \item \textbf{GP Notification Service}: Provides the ability to asynchronously pass notifications to GPs. This service is described further in Section \ref{sect: architecture: gp notification svc}.
\end{itemize}


In order to enable user interaction with services, a client-server-like architectural style is employed for user-service interactions; Section \ref{sect: architecture: clients} discusses this further.


Figure \ref{fig: arch overview / system context diagram} displays the system context diagram (see \S\ref{sect: architecture: modelling language}), where the set of core services, users, and interactions can be seen.


\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 1]{context.png}
  \caption{The system context diagram for the proposed architecture, displaying the service-oriented approach used as the fundamental architectural style for the system.}
  \label{fig: arch overview / system context diagram}
\end{figure}



\subsubsection*{Service-Oriented Architecture}

As the target system's domains can be partitioned with relative ease, an SOA is a suitable choice for the overarching architectural style \cite{fundamentalsOfSWA-SOA}. Although there are other applicable architectural styles for the target system, the following benefits of an SOA were the primary driving factors in the decision to prioritise it over other architectural styles.


\begin{itemize}
  \item Services can be developed independently, reducing time-to-market, as independent teams can develop each service, and improving business agility, as each service's business rules can be adapted independently, provided the boundaries within the architecture are enforced effectively \cite{ibmSOA}. This is primarily an advantage over more rigid architectures, such as those employing a monolithic style.

  \item Services can be deployed independently, facilitating the maintainability, short-term scalability (elasticity), and long-term scalability of the target system. This is primarily an advantage over architectures which are designed to have a one-to-one mapping from system instance to deployment machine, such as an architecture employing a layered monolithic style.

  \item Services are more independent with respect to failure than other architectural styles. This means that if one service fails, the failure of other services is not guaranteed, which is particularly beneficial for the target system, as the domains are mostly disconnected. For example, if the GP Notification Service fails, the other services in the system are not guaranteed to fail, meaning that the system will still provide the majority of its functionality to users. Overall, this improves the system's fault-tolerance.

  \item Similarly to failure, the services are more independent with respect to performance than other architectural styles. For example, if the GP Notification Service handles requests slowly due to a bug in its implementation, the Ambulance Service would be unaffected in terms of performance, provided it is deployed on a different machine; this is particularly beneficial for the target system, as some services, such as the Patient Information Service, require a certain level of performance to function as required.

  \item Due to the network-based nature of an SOA, services and clients are typically designed to be more robust to failure, improving the overall reliability of the system.

  \item Integration with external systems, such as Hospitals (see requirement 8 in Section \ref{sect: requirements: functional}), is facilitated, as the target system will be deployed on a network due to the nature of an SOA. Similarly, integration with legacy systems which might need to be included in the newly developed system is facilitated \cite{ibmSOA}.

  \item The enforcement of architectural boundaries of the target system's domain is improved, as each service's boundary can be mapped directly to each domain's architectural boundary \cite{fundamentalsOfSWA-SOA}.

  \item The domain-driven separation of services, in combination with their low levels of interaction, mitigate the negative effects of an SOA, including selecting an appropriate granularity and handling service choreography/orchestration \cite{fundamentalsOfSWA-SOA}.
\end{itemize}






\newpage
\subsection{Appointments Service}
\label{sect: architecture: appt svc}

The Appointments Service handles read and write requests relating to patient appointments. The service is designed with a relatively typical architecture for a read-heavy workloads, consisting of a service which contains the business logic for the Appointments Service, a datastore, and a cache. Figure \ref{fig: appt svc container diagram} displays the container diagram for the Appointments Service.

\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 1]{appointment-container.png}
  \caption{The Appointments Service described using a container diagram.}
  \label{fig: appt svc container diagram}
\end{figure}



\subsubsection*{Datastore}
The Appointments Service's datastore is used to persist data relating to appointments, improving the service's reliability. The datastore is integrated within the Appointments Service's architecture in such a way that the datastore component is dependent on the service component within the Appointments Service, rather than the other way round. This integration style employs the Stable Abstractions Principle (see \S\ref{sect: process: resources}), as the dependency is pointing from the less stable datastore to the more stable business rules contained within the service component.

The application of the SAP also follows the advice given in Martin's Clean Code regarding how datastores should be integrated within architectures \cite{cleanArch-databasesAreDetails}, meaning that the choice of data storage technology is not confined by the service's implementation, allowing for solutions ranging from a simple file system to a complex RDBMS to be used, improving both the maintainability and scalability of the Appointments Service.



\subsubsection*{Cache}
To improve the performance of the Appointments Service with relatively low overhead, an in-memory cache is used to respond to some requests without querying the datastore. In order to do so, the cache would store requests and their respective results as they are returned from the service after they had been retrieved from the datastore for the first time.

Two key considerations when introducing a cache into a system are how consistency and coherency will be handled during its operation. Handling these concerns, particularly if the cache or service to which the cache is applied to is replicated, can quickly become a complex problem which introduces a significant amount of overhead \cite{dataIntensiveApps-ConsistencyAndConsensus}. Fortunately, as the Appointments Service's workload is read-heavy, the trade-off of increased overhead is likely worth it when considering the potential performance gains introduced by the cache. Other overhead introduced by the cache, which includes the storing of entries, checking of entries, and handling evictions, is considered to be marginal when compared against the potential performance gains provided by the cache.

As it is assumed that there are many users, as the system is designed for the NHS, it is likely that evicting items from the cache on the commonly employed lease-recently-used (LRU) basis is inefficient. This is because the cache will quickly fill up with requests relating to individual users which cannot be reused for other users (e.g. fetching a user's set of appointments), potentially evicting cached information which can be reused (e.g. the grand total of number of appointments for all users). While an alternative cache eviction policy, such as a least-frequently used (LFU) or re-reference interval prediction (RRIP) policy, it considered as an implementation detail to determine this, and is therefore excluded from the scope of the architecture.






\newpage
\subsection{Patient Information Service}
\label{sect: architecture: patient information svc}

The Patient Information Service handles all create, read, update, and delete (CRUD) operations relating to patient information, including personal information, such as patient addresses, as well as medical information, such as blood pressure readings. The service employs the use of role-based authentication to provide different users access to different data, as information handled by the service is considered highly sensitive \cite{EUHealthDataProtection} and different users need different access permissions as per the system requirements (see \S\ref{sect: requirements: functional}).


Figure \ref{fig: patient information container diagram} displays a container diagram for the Patient Information Service.

\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 1]{patient-container.png}
  \caption{The Appointments Service described using a container diagram.}
  \label{fig: patient information container diagram}
\end{figure}


One of the key components of the Patient Information Service is the Service component. Figure \ref{fig: patient information component diagram} displays a component diagram for this component, with the arrows representing the direction of dependency between the constituent parts.


\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 0.9]{pateint-component.png}
  \caption{The Appointments Service's Service component described using a component diagram.}
  \label{fig: patient information component diagram}
\end{figure}

It can be seen from the dependencies shown in Figure \ref{fig: patient information component diagram} that the Stable Abstractions Principle (see \S\ref{sect: process: resources}) is applied, such that all dependencies are pointing towards an abstract concept, such as an interface or the implementation of the business rules in the Service subcomponent (marked with an asterisk in the diagram).




\subsubsection*{Datastore \& Cache}
As the data handled by the Patient Information Service and the Appointments Service (see \S\ref{sect: architecture: appt svc}) are both related to individual patients and are associated with read-heavy workloads, the datastore and cache used within the Patient Information Service are similar to those used in the Appointments Service (see \S\ref{sect: architecture: appt svc}), with respects to both operation and reasons for introducing them as part of the architecture (i.e. reliability and performance).




\subsubsection*{Multilevel Priority Queue}
One way in which the Patient Information Service differs from the Appointments Service is the requirement to handle bursty write behaviour (i.e. write behaviour that experiences spikes in workload) when patient information is generated by GPs. As this behaviour contrasts significantly to typical read-heavy workloads of the Patient Information Service, an additional architectural feature of a multilevel priority queue is introduced to handle all write requests sent to the service.

A multilevel priority queue is a task queue which consists of multiple queues, each of which associated with a different priority level. Inputted tasks are enqueued onto a queue with respect to their given priority level, with the processing element(s) (e.g. the Service component in the proposed architecture) taking tasks from the data structure based on descending priority, meaning that more important tasks are completed before less important ones \cite{osConceptsMultilevelQueue}.

A multilevel priority queue is employed within proposed architecture to support the unique bursty write workloads without interrupting the standard non-bursty write workloads. Bursty write workloads, such as the updating of patient information, gathered during testing procedures, are prioritised lower than non-bursty workloads, such as standard updates to patient information (e.g. a change in address), with the service component handling tasks in an order with respect to their priority. The queue nature of the multilevel priority queue also enables for write requests to be delayed as to avoid disrupting and invalidating read workloads, which are likely more important.

Although multilevel priority queues are commonly implemented as multilevel feedback queues, where tasks are moved between queues depending on the amount of time they have been worked on for \cite{osConceptsMultilevelFeedbackQueue}, such an implementation is unsuitable for the target system's architecture, as it is likely unfair to change the priority of each task once it has been assigned.





\subsection{GP Notification Service}
\label{sect: architecture: gp notification svc}
The GP Notification Service is a comparatively simple service which provides the ability to asynchronously pass notifications to GPs through the use of a publish-subscribe messaging system. This service was introduced in the architecture for the following primary reasons.

\begin{enumerate}
  \item The GP Notification Service allows for the GP client device to be decoupled from the rest of the infrastructure which sends notifications to GPs, such as the hospital.

  \item The addition of future features which require GP notifications are greatly facilitated, as the new features would simply need to interact with the GP Notification Service, with no other architectural changes being required.

  \item Future scaling of the system is better supported with a publish-subscribe architecture in comparison to direct communication between services sending notifications and GP interface devices.

  \item The GP Notification Service can buffer notifications sent to GPs, enabling asynchronous communication, which in turn can improve the reliability of the system. For example, if a GPs device briefly goes offline, notifications are not necessarily lost as the GP Notification Service can buffer them while the device is offline; however, if services were to communicate directly with GP devices, then notifications would have likely been lost in this scenario.
\end{enumerate}

Figure \ref{fig: gp notifcation service container diagram} displays a container diagram for the GP Notification Service.

\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 1]{gp-container.png}
  \caption{The GP Notification Service described using a container diagram.}
  \label{fig: gp notifcation service container diagram}
\end{figure}



One of the key components within the Appointments Service is the Service component; Figure \ref{fig: patient information component diagram} displays the component diagram for this component.

Similarly to the Service component within the Appointments Service (see \S\ref{sect: architecture: appt svc}), the Stable Abstractions Principle and Common Closure Principle (see \S\ref{sect: process: resources}) are applied, such that dependencies point towards more stable components.

\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 0.9]{gp-component.png}
  \caption{The GP Notifications's Service component described using a component diagram.}
  \label{fig: gp notifcation service component diagram}
\end{figure}



\subsubsection*{Publish-Subscribe Pattern}
The GP Notification Service applies an event-driven architectural style in the form of a publish-subscribe (pub-sub) system which buffers notifications sent from other services.

A pull configuration is used, where the GP client device receives notifications by polling the GP Notification Service, rather than a push configuration, where the GP Notification Service would actively communicate with the GP client device to deliver notifications, for the following reasons.

\begin{enumerate}
  \item The GP devices are external to the system, meaning that initialising communication from the GP Notification Service to each GP device is complicated to achieve in comparison to the other way around \cite{googleCloudPubSub}.

  \item The rate of communication (e.g. polling frequency) can be dynamically adjusted based on the GP device's current network connection. This is more beneficial than the GP Notification Service having this control, as the GP device's network connection is likely to fluctuate more than the GP Notification Service's connection given that it is a user device.

  \item The polling interval can be adjusted for each individual GP by the GP's device, allowing for a trade-off in network usage and the amount of delay caused by the gap between the notification being received and polled. For example, if the GP's device has a poor internet connection or is battery powered, the rate of polling could be decreased to improve network efficiency or reduce power consumption.

  \item The notifications being sent to GPs are assumed to not be time-critical, meaning that the delay of messages caused by a pull configuration does not detract from the functionality of the system.
\end{enumerate}





\newpage
\subsection{Ambulance Service}
\label{sect: architecture: ambulance svc}

The Ambulance Service handles all ambulance-related concerns for the target system, including the logging of calls, the dispatching of ambulances, and the indication of callouts being dealt with. The ambulance-related requirements of the target system's domain appears relatively disconnected from other requirements, providing good reason for this service to be a part of the chosen architecture for this report.

\vspace{4mm}
\begin{figure} [H]
  \centering
  \includegraphics[scale = 0.65]{ambulance-container.png}
  % \missingfigure{Ambulance Svc Container Diagram}
  \caption{The Ambulance Service described using a component diagram.}
  \label{fig: ambulance svc container diagram}
\end{figure}



\subsubsection*{Publish-Subscribe Pattern}
Similarly to the GP Notification Service (see \S\ref{sect: architecture: gp notification svc}), the Ambulance Service employs an event-driven architectural style in the form of a publish-subscribe (pub-sub) messaging system. The pub-sub system is used primarily for performance purposes, and therefore uses a push configuration for message delivery, contrasting to the pull configuration used for the GP Notification Service.

A push configuration is more performant in comparison to a pull configuration with respect to message delivery latency, because the delay between the message arriving at the Ambulance Service and being sent to the client device is marginal, in comparison to a pull configuration where the delay is on average half of the polling interval \cite{googleCloudPubSub}. Although a push configuration adds complexity from communicating with client devices outside the system's internal network, and reduces flexibility for the power and network consumption for client devices, these trade-offs are accepted in favour of the reduced message delivery delay, as this characteristic is critical to the Ambulance Service's functionality.








\subsection{Clients}
\label{sect: architecture: clients}


The clients within the architecture offer the functionality of the services in the form of a user interface (UI). All clients share a similar architecture, which can be seen in Figures \ref{fig: appt svc container diagram}, \ref{fig: patient information container diagram}, \ref{fig: gp notifcation service container diagram}, and \ref{fig: ambulance svc container diagram}, and provides the support for a variety of different device types, as well as the potential for functionality, such as form validation.


The overarching architectural style applied for communication between clients and services is the client-server style, where the clients, such as patient mobile devices, communicate with internal services, such as the Patient Information Service, through the use of standard web technologies (e.g. HTTP/HTTPS) to offload computation and data-storage responsibilities.

In order to provide seamless, flexible, reliable, and secure integration with the services, the clients exhibit two primary architectural patterns within the client-server style: gateways and backends for frontends.


\subsubsection*{Gateway Pattern}

The gateway architectural pattern employs an intermediate service to mediate requests which pass from client devices to the services within a system, rather than having client devices communicate directly with the services.

The gateway architectural pattern provides the following advantages.

\begin{itemize}
  \item Cross-cutting concerns, such as authentication, and data transformations, can be handled in a uniform manner for all client devices, simplifying the implementation of each user interface \cite{micosoftGatewayPattern}.

  \item The communication protocol used by requests can be changed before being forwarded to services, allowing for client devices to communicate using web-based protocols (e.g. HTTP/HTTPS) with services that are implemented to communicate using non-web-based protocols, such as QUIC \cite{QUICProtocol}\cite{micosoftGatewayPattern}.

  \item As all requests are passed through a single location before entering the internal system where the services lie, the gateway pattern facilitates the application of performance and security measures, such as load balancing and request filtering.

  \item Requests to different services can be coalesced to reduce data ingress and egress for client devices, improving performance. For example, if a patient's mobile device was loading the patient's information and appointments, the two separate requests to the Patient Information Service and Appointments Service could be combined into a single request to the respective gateway node, reducing the required network communication overhead \cite{micosoftGatewayPattern}.
\end{itemize}

The primary disadvantages of the gateway architectural pattern is the increased architectural complexity and the potential performance concerns surrounding the gateway services becoming a bottleneck or single point of failure. As  the gateways used in the chosen architecture in this report have potential to be stateless, they can be replicated to mitigate the issues of performance and reliability; however, the issue of increased architectural complexity cannot be mitigated. Overall, the advantages of the using gateways for the target system's architecture outweigh the disadvantages.




\subsubsection*{Backend For Frontend Pattern}

The backend for frontend (BFF) architectural pattern is the application of one intermediary service (the backends) per client-side user interface (the frontends).

While similar to the gateway pattern, and often considered synonymous \cite{bffsCouldBeConsideredGateways}, the BFF pattern is applied within the chosen architecture for this report for different reasons to the gateway pattern, which are as follows.

\begin{itemize}
  \item The development of frontend applications using the humble object pattern  is greatly facilitated, as the business logic for the applications are contained within the backend services instead. The humble object pattern is the separation of logic from frontend components and increases the testability of such components; the application of the humble object pattern is generally considered to be good software-engineering practice \cite{cleanArch-HumbleObjectPattern}.

  \item Each BFF backend can be tailored specifically to its respective frontend, allowing for platform-specific intricacies to be handled cleanly, in turn facilitating development, and improving performance and maintainability. This is in contrast to the gateway pattern which uses a single backend for all frontends.
\end{itemize}

The trade-offs of using both the BFF and gateway pattern in the target system's architecture are discussed in Section \ref{sect: evaluation: current considerations} of this report.









\subsection{Authentication}
\label{sect: architecture: authentication}

Authentication is a critical part of the system's functionality, as all services require some form of authentication to function in-line with the system's specification. For example, functional requirement 2 in Section \ref{sect: requirements: functional} can be achieved through the use of authentication.

In order to include authentication within the system's architecture, the OAuth 2 framework \cite{OAuth2} was chosen for the following reasons.

\begin{itemize}
  \item It is a proven authentication framework, as it is used by renowned companies such as Facebook, GitHub, and DigitalOcean \cite{digitalOceanOAuth2}
  \item It enables single-sign on for the target system, which is beneficial from a user standpoint \cite{oauth2SSO}.
  \item The protocol used to authenticate users is simple in comparison to other authorisation techniques.
  \item It provides simple integration with third-party services \cite{digitalOceanOAuth2}. This is beneficial for the target system, as external systems, such as those used within hospitals, may require authorisation for their required access to the system.
  \item The primary architectural elements required for the framework can be \say{bolted} onto the rest of the architecture, allowing for the component coupling dependencies to be followed (see \S\ref{sect: process: resources}), in turn improving the flexibility and maintainability of the architecture as a whole.
\end{itemize}