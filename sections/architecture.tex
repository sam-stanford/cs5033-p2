\subsection{Modelling Language}
\label{sect: architecture: modelling language}

A relatively informal modelling language is used to describe the final architecture produced for this report, with the C4 model being used in combination with a notation similar to UML. This combination was chosen as all team members were relatively familiar with the concepts used for both practices, focussing the project's time to designing and evaluating the architecture, rather than learning modelling languages.



\subsubsection*{C4 Model}
The C4 model primarily consists of four different architectural viewpoints, described in the form of diagrams, which represent an architecture as a hierarchical set of abstractions \cite{c4Model}. The viewpoints are designed to reflect to how software architects and developers think about and build software, and are summarised as follows.

\begin{itemize}
  \item \textbf{System Context Diagram}: A viewpoint which describes a system's architecture as a whole, allowing viewers to see the \say{big picture}. The diagram has a focus on the users of the system, rather than specific details, such as which technologies are used. Section \ref{sect: architecture: overview} explores the system context diagram for the chosen architecture in this report.

  \item \textbf{Container Diagram}: A viewpoint which shows the details of a single subsystem within a system context diagram. The diagram is composed of containers, which represent an application or datastore (e.g. a web application, filesystem, database, etc.), and high-level references to other subsystems. Section \ref{sect: architecture: container diagrams} explores several container diagrams for the chosen architecture in this report.

  \item \textbf{Component Diagram}: A viewpoint which describes a single container within a container diagram, with respect to the major building blocks (i.e. components) that make up the container. Component diagrams contain some specific details, such as the technology used to implement or communicated between services, but still provide a relatively high-level overview of a container. Section \ref{sect: architecture: component diagrams} explores some component diagrams for the chosen architecture in this report.

  \item \textbf{Code Diagram}: A viewpoint which describes a single component within a component diagram as it is implemented within code, including the classes and interface involved, and their relationships. Code diagrams are not explored in this report, as they reference relatively low-level implementation details, and could be automatically generated from code written during the system's development.
\end{itemize}

The C4 model also includes three supplementary diagrams: the system landscape diagram, the dynamic diagram, and the deployment diagram. However, none of these are reference within this report, as the four core diagrams are sufficient to capture the chosen architecture \cite{c4Model}.


\todo{code diagrams not used}


\subsubsection*{Notation}
\todo{find out from Ben \& Jordan what notation is used}





\subsection{Overview}
\label{sect: architecture: overview}

The architecture derived for the scenario listed in Appendix \ref{appendix: scenario} is fundamentally a service-oriented architecture (SOA), as the key functionality of the system is implemented by multiple independent, distributed services. The core services used and their roles within the architecture are as follows.

\begin{itemize}
  \item \textbf{Patient Information Service}: Handles create/read/update/delete (CRUD) operations relating to patient information, employing business rules in combination with authentication to authorise information appropriately. . This service is described further in Section \ref{sect: architecture: Patient Information svc}.

  \item \textbf{Appointment Service}: Handles CRUD operations relating to appointments, employing business rules in combination with authentication to authorise information appropriately. This service is described further in Section \ref{sect: architecture: appt svc}.

  \item \textbf{Ambulance Service}: Affords the logging of calls and the dispatching of ambulances. This service is described further in Section \ref{sect: architecture: ambulance svc}.

  \item \textbf{GP Notification Service}: Provides the ability to asynchronously pass notifications to GPs. This service is described further in Section \ref{sect: architecture: gp notification svc}.
\end{itemize}

\todo{which reqs are satisfied by which svc?}


In order to enable user interaction with services, a client-server-like architectural style is employed for user-service interactions; Section \ref{sect: architecture: clients} discusses this further.


Figure \ref{fig: arch overview / system context diagram} displays the system context diagram (see \S\ref{sect: architecture: modelling language}), where the set of core services, users, and interactions can be seen.


\vspace{4mm}
\begin{figure} [H]
  \centering
  % \includegraphics[scale = 0.65]{IMAGE.png}
  \missingfigure{System context diagram}
  \caption{The system context diagram for the chosen architecture, displaying the service-oriented approach used as the fundamental architecture for the system.}
  \label{fig: arch overview / system context diagram}
\end{figure}



\subsubsection*{Service-Oriented Architecture}

As the target system's domains can be partitioned with relative ease, an SOA is a suitable choice for the overarching architectural style \cite{fundamentalsOfSWA-SOA}. Although there are other applicable architectural styles for the target system, the following benefits of an SOA were the primary driving factors in the decision to prioritise it over other architectural styles.


\begin{itemize}
  \item Services can be developed independently, reducing time-to-market, as independent teams can develop each service, and improving business agility, as each service's business rules can be adapted independently, provided the boundaries within the architecture are enforced effectively (see \S\todo{ref SOA not an arch in Eval sec})\cite{ibmSOA}. This is primarily an advantage over more rigid architectures, such as those using a monolithic style.

  \item Services can be deployed independently, facilitating the maintainability, short-term scalability (elasticity), and long-term scalability of the target system. This is primarily an advantage over architectures which are designed to have a one-to-one mapping from system instance to deployment machine, such as an architecture employing a layered monolithic style.

  \item Services are more independent with respect to failure than other architectural styles. This means that if one service fails, the failure of other services is not guaranteed, which is particularly beneficial for the target system, as the domains are mostly disconnected. For example, if the GP Notification Service fails, the other services in the system are not guaranteed to fail, meaning that the system will still provide the majority of its functionality to users. Overall, this makes the system more resilient to

  \item Similarly to failure, the services are more independent with respect to performance than other architectural styles. For example, if the GP Notification Service handles requests slowly due to a bug in its implementation, the Ambulance Service would be unaffected in terms of performance, provided it is deployed on a different machine; this is particularly beneficial for the target system, as some services, such as the Patient Information Service, require a certain level of performance to function as required.

  \item Due to the network-based nature of an SOA, services and clients are typically designed to be more robust to failure, improving the overall reliability of the system.

  \item Integration with external systems, such as the \todo{hospital system}, is facilitated, as the target system will be deployed on a network due to the nature of an SOA. Similarly, integration with legacy systems which might need to be included in the newly developed system is facilitated \cite{ibmSOA}.

  \item The enforcement of architectural boundaries of the target system's domain is improved, as each service's boundary can be mapped directly to each domain's architectural boundary \cite{fundamentalsOfSWA-SOA}.

  \item The domain-driven separation of services, in combination with their low levels of interaction, mitigate the negative effects of an SOA, including selecting an appropriate granularity and handling service choreography/orchestration \cite{fundamentalsOfSWA-SOA}.
\end{itemize}







\subsection{Appointments Service}
\label{sect: architecture: appt svc}

The Appointments Service handles read and write requests relating to patient appointments. The service is designed with a relatively typical architecture for a read-heavy workload (see \ref{} \todo{assump that appointments are read more than written}), consisting of a service which contains the business logic for the Appointments Service, a datastore, and a cache. Figure \ref{fig: appt svc container diagram} displays the container diagram for the Appointments Service. \todo{right diagram?}

\vspace{4mm}
\begin{figure} [H]
  \centering
  % \includegraphics[scale = 0.65]{IMAGE.png}
  \missingfigure{Appt Svc Container Diagram}
  \caption{The Appointments Service described using a component diagram.}
  \label{fig: appt svc container diagram}
\end{figure}



\subsubsection*{Datastore}
The Appointments Service's datastore is used to persist data relating to appointments, improving the service's reliability. From Figure \ref{fig: appt svc container diagram} (CAN IT?\todo{can it?}), it can be seen that the datastore is integrated within the architecture as a dependent on the service component within the Appointments Service, rather than the other way round. This integration style employs the Stable Abstractions Principle (see \S\ref{sect: process: resources}), as the dependency is pointing from the less stable datastore to the more stable business contained within the service component.

The application of the SAP also follows the advice given in Martin's Clean Code regarding how datastores should be integrated within architectures \cite{cleanArch-databasesAreDetails}, and also does not confine the choice of data storage technology, allowing for solutions ranging from a simple file system to a complex RDBMS to be used, improving both the maintainability and scalability of the Appointments Service.



\subsubsection*{Cache}
To improve the performance of the Appointments Service with relatively low overhead, an in-memory cache is used to respond to some requests without querying the datastore. In order to do so, the cache would store requests and their respective results as they are returned from the service/datastore after they had been retrieved from the service/datastore for the first time

Two key considerations when introducing a cache into a system are how consistency and coherency will be handled during its operation. Handling these concerns, particularly if the cache or service to which the cache is applied to is replicated, can quickly become a complex problem which introduces a significant amount of overhead \cite{dataIntensiveApps-ConsistencyAndConsensus}. Fortunately, as the Appointments Service's workload is read-heavy (see \ref{} \todo{complete ref to assumptions}), the overhead introduced is likely worth handling when considering the potential performance gains introduced by the cache. Other overhead introduced by the cache, including storing entries, checking for entries, and handling evictions is considered to be marginal when compared against the potential performance gains provided.

As it is assumed that there are many users \todo{cite assumptions}, it is likely that evicting items from the cache on a commonly used lease-recently-used (LRU) basis is inefficient. This is because the cache will quickly fill up with requests relating to individual users which cannot be reused for other users (e.g. fetching a user's set of appointments), potentially evicting cached information which can be reused (e.g. the grand total of number of appointments for all users). While an alternative cache eviction policy, such as least-frequently used (LFU) or re-reference interval prediction (RRIP) policies, it considered as an implementation detail to determine this, and is therefore excluded from the scope of the architecture.







\subsection{Patient Information Service}
\label{sect: architecture: patient information svc}

\vspace{4mm}
\begin{figure} [H]
  \centering
  % \includegraphics[scale = 0.65]{IMAGE.png}
  \missingfigure{Patient Information Container Diagram}
  \caption{The Appointments Service described using a component diagram.}
  \label{fig: patient information container diagram}
\end{figure}



\subsubsection*{Datastore \& Cache}
As the data handled by the Patient Information Service and the Appointments Service (see \S\ref{sect: architecture: appt svc}) are both related to individual patients and are associated with read-heavy workloads (see \ref{} \todo{ref assumptions}), the datastore and cache used within the Patient Information Service are similar to those used in the Appointments Service (see \S\ref{sect: architecture: appt svc}), with respects to both operation and reasons for introducing them as part of the architecture (i.e. reliability and performance).




\subsubsection*{Multilevel Priority Queue}
One of the more interesting architectural features of the Patient Information Service is the application of a multilevel priority queue to handle write requests from \todo{look at spec / requirements to find proper wording}

\cite{osConceptsMultilevelQueue}




\subsection{GP Notification Service}
\label{sect: architecture: gp notification svc}

The GP Notification Service is a comparatively simple service which provides the ability to asynchronously pass notifications to GPs through the use of a publish-subscribe messaging system. This service was introduced in the architecture for the following primary reasons.

\begin{enumerate}
  \item The GP Notification Service allows for the GP client device to be decoupled from the services which send notifications to GPs, such as the \todo{which service?}.

  \item The addition of future features which require GP notifications are greatly facilitated, as the new features would simply need to interact with the GP Notification Service, with no other architectural changes being required.

  \item Future scaling of the system is better supported with a publish-subscribe architecture in comparison to direct communication between services sending notifications and GP interface devices.

  \item The GP Notification Service can buffer notifications sent to GPs, enabling asynchronous communication, which in turn can improve the reliability of the system. For example, if a GPs device briefly goes offline, notifications are not necessarily lost as the GP Notification Service can buffer them while the device is offline; however, if services were to communicate directly with GP devices, then notifications would have likely been lost in this scenario.
\end{enumerate}

Figure \ref{fig: gp notifcation service container diagram} displays a container diagram for the GP Notification Service.

\vspace{4mm}
\begin{figure} [H]
  \centering
  % \includegraphics[scale = 0.65]{IMAGE.png}
  \missingfigure{GP Notification Svc Container Diagram}
  \caption{The Appointments Service described using a component diagram.}
  \label{fig: gp notifcation service container diagram}
\end{figure}


\subsubsection*{Publish-Subscribe Pattern}
The GP Notification Service applies an event-driven architectural style in the form of a publish-subscribe (pub-sub) ,system which buffers notifications sent from other services, such as the \todo{what?},

A pull configuration is used, where the GP client device receives notifications by polling the GP Notification Service, rather than a push configuration, where the GP Notification Service would actively communicate with the GP client device to deliver notifications, for the following reasons.

\begin{enumerate}
  \item The GP devices are external to the system, meaning that initialising communication from the GP Notification Service to each GP device is complicated to achieve in comparison to the other way around \cite{googleCloudPubSub}.

  \item The rate of communication (e.g. polling frequency) can be dynamically adjusted based on the GP device's current network connection. This is more beneficial than the GP Notification Service having this control, as the GP device's network connection is likely to fluctuate more than the GP Notification Service's connection.

  \item The polling interval can be adjusted for each individual GP by the GP's device, allowing for a trade-off in network usage and the amount of delay caused by the gap between the notification being received and polled. For example, if the GP's device has a poor internet connection or is battery powered, the rate of polling could be decreased to improve network efficiency or reduce power consumption.

  \item The notifications being sent to GPs are assumed to not be time-critical \todo{ref assumption?}.
\end{enumerate}



As seen in Figure \ref{fig: appt svc container diagram} the GP Notification service






\subsection{Ambulance Service}
\label{sect: architecture: ambulance svc}

The Ambulance Service handles all ambulance-related concerns for the target system, including the logging of calls, the dispatching of ambulances, and the indication of callouts being dealt with. The ambulance-related requirements of the target system's domain appears relatively disconnected from other requirements, providing good reason for this service to be a part of the chosen architecture for this report.

\vspace{4mm}
\begin{figure} [H]
  \centering
  % \includegraphics[scale = 0.65]{IMAGE.png}
  \missingfigure{Ambulance Svc Container Diagram}
  \caption{The Ambulance Service described using a component diagram.}
  \label{fig: ambulance svc container diagram}
\end{figure}



\subsubsection*{Publish-Subscribe Pattern}

Similarly to the GP Notification Service (see \S\ref{sect: architecture: gp notification svc}), the Ambulance Service employs an event-driven architectural style in the form of a publish-subscribe (pub-sub) messaging system. The pub-sub system is used primarily for performance purposes, and therefore uses a push configuration for message delivery, contrasting to the pull configuration used for the GP Notification Service.

A push configuration is more performant in comparison to a pull configuration with respect to message delivery latency, because the delay between the message arriving at the Ambulance Service and being sent to the client device is marginal, in comparison to a pull configuration where the delay is on average half of the polling interval \cite{googleCloudPubSub}. Although a push configuration adds complexity from communicating with client devices outside the system's internal network, and reduces flexibility for the power and network consumption for client devices, these trade-offs are accepted in favour of the reduced message delivery delay, as this characteristic is critical to the Ambulance Service's functionality.








\subsection{Clients}
\label{sect: architecture: clients}

\todo{client-server pattern / style}
\todo{container diagrams for clients}

The clients within the architecture offer the functionality of the services in the form of a user interface (UI). Figure \ref{fig: arch client} displays WHAT \todo{what}.

\vspace{4mm}
\begin{figure} [H]
  \centering
  % \includegraphics[scale = 0.65]{IMAGE.png}
  \missingfigure{System context diagram}
  \caption{A component diagram for the WHAT? client, displaying the use of a gateway and backend.}
  \label{fig: arch overview / system context diagram}
\end{figure}

\todo{caption}


In order to provide seamless, flexible, reliable, and secure integration with the services, the clients exhibit two primary architectural patterns: gateways and backends for frontends.


\subsubsection*{Gateway Pattern}

The gateway architectural pattern employs an intermediate service to mediate requests which pass from client devices to the services within a system, rather than having client devices communicate directly with the services. This can be seen in Figure \ref{}, where the \todo{finish sent}.

The gateway architectural pattern provides the following advantages.

\begin{itemize}
  \item Cross-cutting concerns, such as authentication, and data transformations, can be handled in a uniform manner for all client devices, simplifying the implementation of each user interface \cite{micosoftGatewayPattern}.

  \item The communication protocol used by requests can be changed before being forwarded to services, allowing for client devices to communicate using web-based protocols (e.g. HTTP/HTTPS) with services that are implemented to communicate using non-web-based protocols, such as QUIC \cite{QUICProtocol}\cite{micosoftGatewayPattern}.

  \item As all requests are passed through a single location before entering the internal system where the services lie, the gateway pattern facilitates the application of performance and security measures, such as load balancing and request filtering.

  \item Requests to different services can be coalesced to reduce data ingress and egress for client devices, improving performance. For example, if a patient's mobile device was loading the patient's information and appointments, the two separate requests to the Patient Information Service and Appointments Service could be combined into a single request to the respective gateway node, reducing the required network communication overhead \cite{micosoftGatewayPattern}.
\end{itemize}

The primary disadvantages of the gateway architectural pattern is the increased architectural complexity and the potential performance concerns surrounding the gateway services becoming a bottleneck or single point of failure. As  the gateways used in the chosen architecture in this report have potential to be stateless, they can be replicated to mitigate the issues of performance and reliability; however, the issue of increased architectural complexity cannot be mitigated. Overall, the advantages of the using gateways for the target system's architecture outweigh the disadvantages.




\subsubsection*{Backend For Frontend Pattern}

The backend for frontend (BFF) architectural pattern is the application of one intermediary service (the backends) per client-side user interface (the frontends).

While similar to the gateway pattern, and often considered synonymous \cite{bffsCouldBeConsideredGateways}, the BFF pattern is applied within the chosen architecture for this report for different reasons to the gateway pattern, which are as follows.

\begin{itemize}
  \item The development of frontend applications using the humble object pattern  is greatly facilitated, as the business logic for the applications are contained within the backend services instead. The humble object pattern is the separation of logic from frontend components and increases the testability of such components; the application of the humble object pattern is generally considered to be good software-engineering practice \cite{cleanArch-HumbleObjectPattern}.

  \item Each BFF backend can be tailored specifically to its respective frontend, allowing for platform-specific intricacies to be handled cleanly, in turn facilitating development, and improving performance and maintainability. This is in contrast to the gateway pattern which uses a single backend for all frontends.
\end{itemize}


The trade-offs of using both the BFF and gateway pattern in the target system's architecture are discussed in Section \ref{} of this report.








\subsection{Authentication}
\label{sect: architecture: authentication}



