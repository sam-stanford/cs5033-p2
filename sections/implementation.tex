\todo{deploy on different nodes to ensure failures are indep. If the target user-base was small, it might be worth using a single node for cost, but the size of the NHS user-base is not small}

\todo{see Clean Arch - says start off with single service with clear arch boundaries, then split into multiple services as system grows}

\todo{Add references to the refs.bib files and cite them in the implementation.tex file}

\subsection{Implementation Plan}
\label{sect: implementation: implementation plan}

Following our C4 model, the implementation of the patient digital appointments and management system should take a top-down approach. This should begin with the system context, then the containers, then the components, followed by the actual classes. By structuring the implementation in the same order that the architecture was designed, the architecture-driven development falls into a natural order.
Top-down implementation, also known as ‘stepwise refinement', imposes a hierarchical structure on the program matching that of the C4 architecture. By starting with defining the solution at the highest level of functionality, not only does the implementation begin and remain structured but individual development teams can be assigned to specific branches of the program maintaining architectural boundaries while promoting scaling and performance. These initial branches would be skeletons for the web application, desktop application, and mobile application as well as the initial gateway, database, cache, and event queue. It is clear that another advantage of the top-down approach is that the foundational elements of the system are implemented first meaning that they're available once the individual services are developed.
Another benefit of organising the development in this manner is that the existing services are built into the system as a primary concern rather than as an after thought. We have inferred from the system specification that the the services that assign patients to hospitals and that order testing kits are both external services. Following a bottom-up implementation paradigm, once the core functionality of the system was built out, code would have to be revised and refactored to integrate with these external services.
The main goal of architecture-driven implementation is to minimise architectural drift an erosion. Drift refers to introduction of a design decision in the code that was not included in the architecture but does not necessarily violate its constraints while architectural erosion refers to design decisions in the code that do violate the originally produced architecture [1]. The methodologies to reduce these properties are discussed in the section below.

\subsection{Agile Development Paradigm}
\label{sect: implementation: agile development paradigm}

By using the agile development paradigm and adding to the codebase in sprints, the individual development teams assigned to different services will stop and re-evaluate their progress respective to each other periodically. Not only does this enable precise organisation but it also gives the teams a chance to reflect on the architectural degradation. At the end of each sprint cycle, the implementation is to be ‘synced' with the architecture. This could mean updating either the code or the initial architecture depending on the conclusions made during an analysis. In line with the agile manifesto [2], continuously focusing attention on good design decisions will enhance agility.
Syncing of the implementation and architecture should not be limited to sprint meetings but should also occur whenever a ‘fault' is encountered. In this context, a fault is defined as when it is uncovered that the implementation will not work as intended due to a misalignment of goals with the architecture. If the development team can effectively manage the gap between the architecture and implementation then the documentation will most accurately reflect the implementation allowing other stakeholders to stay informed for decision-making processes. This includes, but is not limited to, allocating development resources to the different parts of the system as a response to varying levels of success across the development teams.

\subsection{Enforcement of Architectural Styles and Constraints}
\label{sect: implementation: enforcement of architectural styles and constraints}

To ensure that our implementation meets all the non-functional requirements and to require a high level of security, reliability, and availability while safely managing concurrent processes we must ‘hoist' these properties. George Fairbanks defines architectural hoisting as “the direct ownership, management, or guarantee by the architecture of a feature, property, or quality attribute” [3]. As an example, we could employ Enterprise Java Beans (now known as Jakarta Enterprise Beans) to hoist the properties of concurrency and scalability. EJB is a Java API that has various purposes such as managing processes and threads while running concurrency management.
Another method which will push our implementation to enforce the architectural styles and constraints is by developing the system in a test-driven manner while deriving the tests from the architecture. At the lowest level, we have unit tests for each smallest element of the architecture. These tests will insist that these ‘building blocks' each function correctly on their own before we can check cross-service functionality. After the unit tests, we can also derive integration tests from the architecture. Each connection in the various design diagrams represents an interface between two containers. components, or classes. Integrations tests shall be written to check that each interface behaves appropriately and that the subsystems of the patient digital appointments and management system produce the expected output from various types of input. These tests should not overwhelm development but should be comprehensive enough that ‘most' bugs are caught. Of course it is difficult to explicitly define ‘most' but the amount of tests written will come down to how the product manager allocates development resources. Furthermore, we could take inspiration from Netflix's ChaosMonkey and test our services after taking different nodes down to simulate various failures. In production we should not expect to have such failures due to an AWS setup as described below but due to the vital nature of the system, it is necessary to be able to provide the main functionality even when part of the system has failed.
Another type of testing that can be used to enforce architectural constraints is acceptance tests. Acceptance testing is critical for ironing out faults before deployment, especially in the context of a medical system for which performance and reliability are of utmost importance. Acceptance testing should be run by the individual development teams with access to false datasets to simulate normal system use. A test should be written for each line of interaction through the system to ensure that patients, GPs, the ambulance service, the hospitals, and the health boards are all able to use the services provided by the system correctly. From the flow diagram [4] we can see two different interaction sequences that have two branches created at each decision point. Our acceptance tests should simulate entire interaction sequences and should assert the correct output at each step. This way, we can say with some confidence that the system serves the purpose it is built for.

\subsection{Twelve-Factor App}
\label{sect: implementation: twelve-factor app}

Twelve-factor app is a methodology for software development which consists of 12 principles that should be followed for successful development in the large [5]. When implementing our healthcare system we should be vigilant about each of these principles and should apply them as much as possible. The first of which regards the codebase; the codebase shall be tracked in a version control system such as Git allowing for a high level view of the current implementation while the individual development teams build out their respective services. It also means that in the case of a failure in a production deployment, we could simply rollback the system to a previous version that was working correctly. The other note about the codebase by the twelve-factor app manifesto is that no components should repeat code; all shared code should be factored into libraries which can the injected into the individual components via the dependency/package manager.
Furthermore, the application should never rely on the implicit existence of system-wide packages. The codebase should be structures such that all dependencies are declared completely and exactly in a dependency declaration manifest. It is also essential for a dependency isolation tool to be used as well to avoid implicit dependencies leaking into the rest of the system. If these to protocols are followed, new developers are able to deterministically build and run the codebase with only the language runtime and dependency manager installed. The other advantage of this is that architectural boundaries are respected and represented in the code.
Another noteworthy principle of the twelve-factor app is the principle on backing services. Since our system, as represented in the architecture, relies on multiple different services working in harmony with one another, the implementation should not make distinctions between local and third-party external services. For example, the code should treat a local MySQL database just as it would an instance of the Amazon Relational Database Service. The result of this is that, without refactoring or code changes, external services can be switched for one another. This corollary of this is that new versions of the individual services can be deployed into the system without the need to change the existing implementation which promotes scaling.

\subsection{Technologies}
\label{sect: implementation: technologies}

Before discussing a potential technology stack for the patient digital appointments and management system, I would like to give an overview of the deployment and hosting technologies we can leverage to achieve the high levels of availability and reliability that is required of a critical healthcare system such as the one we have designed. The first of which are AWS Elastic Load Balancers (ELBs) which will distribute the system traffic across multiple EC2 instances in multiple availability zones. The AWS EC2 instances are virtual servers in Amazon's elastic compute cloud on which our implementation would be deployed in order to take advantage of the Amazon Web Services infrastructure. Not only will the load balancer share the traffic across the nodes to reduce the chance of failure due to stress but it will also redistribute traffic from an unresponsive node to other nodes in the pool. This means that even in the event of a single server failure, the system can continue to run and provide the essential healthcare services.
Another product from the AWS family we would utilise is the CodeDeploy system. By using AWS CodeDeploy we would be able to coordinate application deployment and updates across an arbitrary number of EC2 instances. By automating deployments, following the twelve-factor app principle of disposability, we would be able to quickly push new versions to production without the cost of coordinating deployment protocols. It also asserts that the same application revisions would be deployed across all live environments in a consistent and predictable manner. Furthermore, AWS CodeDeploy would allow us to maintain a high level of availability, reliability, and performance due to its active instance health tracking in accordance to custom rules. This would enable us to avoid downtimes and target high-traffic service routes for performance upgrades.
Moving on from cloud computing, the implementation should also utilise the Java framework Spring. Spring is an application development framework for Java which is used to build high-performance, easily testable, and reusable code. Spring supports quick start up and is heavily focused on dependencies which aligns with the twelve-factor app principles for disposability and dependencies. The framework provides a transaction management interface that is highly scalable and supports the requirement for safe concurrency in our system.
Another technology that we could leverage is React. React is a JavaScript library for front-end implementations that focuses on reusing components and not repeating code across classes. This property aligns with the twelve-factor principle of keeping shared code within libraries that can be exposed to explicit classes which need them. Using the react library for our front-end, we could also exploit the advantages of the React Native framework which integrates by design with ReactJS. React Native automatically detects the platform that the application is being run on and then generates the correct code for the platform. This would be extremely beneficial when implementing our system across the desktop application for the general practitioners, the application for the hospital systems interface, and the mobile application for patients. Although React is a JavaScript library, it could still be compatible with the proposed Java Spring back-end as they could communicate via JSON which is mutually supported.
As a backend service we could deploy an Amazon RDS instance which could be managed alongside the EC2 nodes using the AWS Elastic Beanstalk service. AWS RDS automatically backs up the database while integrating with the other AWS services to all be managed by the Elastic Beanstalk service which can orchestrate deployments and updates.

\subsection{Implementation References}
\label{sect: implementation: references}

\begin{itemize}
  \item Whiting, E and Andrews, S. (2020). Drift and Erosion in Software Architecture. Proceedings of the 2020 the 4th International Conference on Information Systems and Data Mining. Available at:  https://dl.acm.org/doi/pdf/10.1145/3404663.3404665
  \item Agile Manifesto (2019). Principles behind the Agile Manifesto. Available at: https://agilemanifesto.org/principles.html
  \item George Fairbanks. Architectural Hoisting (original blog post). Available at: https://www.georgefairbanks.com/blog/architectural-hoisting-original/
  \item Ira's system flow diagram
  \item The Twelve-Factor App. Available at: https://12factor.net
\end{itemize}